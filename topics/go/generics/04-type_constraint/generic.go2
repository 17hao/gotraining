package main

import "fmt"

// =============================================================================

// This interface defines a contraint not based on behavior but based on the
// type of data that is acceptable. This type of constrain is important when
// functions (like Add) need to perform operations (like +) that are not 
// supported by all types.

type addOnly interface {
	type string, int, int8, int16, int32, int64, float64
}

func Add(type T addOnly)(v1 T, v2 T) T {
    return v1 + v2
}

// =============================================================================

// The index function declares that the value of type T must be compliant with
// the new predeclared type constraint "comparable". A type parameter with the
// comparable constraint accepts as a type argument any comparable type. It
// permits the use of == and != with values of that type parameter.

func index(type T comparable)(list []T, find T) int {
	for i, v := range list {
		if v == find {
            return i
		}
    }
    return -1
}

// =============================================================================

type person struct{
    name string
}

func main() {
    fmt.Println(Add(10, 20))
    fmt.Println(Add("A", "B"))
    fmt.Println(Add(3.14159, 2.96))

    durations := []int{5000, 10, 40}
    findDur := 10
    fmt.Printf("found duration %d in %v at index %d\n", findDur, durations, index(durations, findDur))

    people := []person{{name:"bill"}, {name:"jill"}, {name:"joan"}}
    findPerson := person{name:"joan"}
    fmt.Printf("found person %s in %v at index %d\n", findPerson.name, people, index(people, findPerson))
}
